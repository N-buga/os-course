\section{Планирование и вытесняющая многозадачность}

Вам не требуется придумывать какой-то особенный алгоритм планирования - хватит
простейшего Round Robin. Т. е. давайте поработать всем потокам по кругу. Таким
образом выполнение этой части задания сводится к реализации одной сравнительно
простой функции, назовем ее schedule\footnote{Вы можете называть ее как вам
угодно - но помните о чувстве юмора, точнее о его отсутствии.}.

Эта функция выбирает следующий поток исполнения и переключается с текущего
потока на выбранный поток исполнения. Переключение состоит из сохранения
состояния текущего потока и восстановления состояния следующего потока. Пример
переключения вы можете найти в лекции.

Если вы реализовали и проверили работу функции schedule, то для организации
вытесняющей многозадачности вам остается только вызвать эту функции из
обработчика прерывания таймера. Естественно, что вызывать ее на каждое
прерывание слишком сурово, поэтому вам необходимо предусмотреть возможность
отсчитывать время, которое поток занимает процессор и дать потоку поработать
хотя бы несколько миллисекунд\footnote{Если он, конечно, не захочет сам отдать
процессор. Как он может это сделать?}.

Учтите, что поток, на который вы переключитесь из обработчика таймера может
ничего не знать об этом таймере, поэтому послать EOI контроллеру прерываний вы
должны до того, как вызывать функцию schedule.
